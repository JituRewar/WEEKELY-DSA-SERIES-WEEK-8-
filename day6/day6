# ğŸ“… Weekly DSA Series

## Week 8 â€“ Day 6

### Topic: Min Stack (LeetCode 155)

---

## ğŸ§  Problem Statement

Design a stack that supports the following operations in **constant time O(1)**:

* `push(val)` â€“ Push element onto the stack
* `pop()` â€“ Remove the top element
* `top()` â€“ Get the top element
* `getMin()` â€“ Retrieve the minimum element in the stack

This is the classic **Min Stack** problem from **LeetCode 155**.

---

## ğŸ’¡ Approach (Using Two Stacks)

We maintain:

1. **Main Stack** â†’ stores all values
2. **Min Stack** â†’ stores the minimum value at each state

### Logic:

* While pushing:

  * Push value into main stack
  * Push `min(val, minStack.top())` into min stack
* While popping:

  * Pop from both stacks
* `top()` â†’ return main stack top
* `getMin()` â†’ return min stack top

This guarantees **O(1)** time for all operations.

---

## â± Time & Space Complexity

* **Time Complexity:** O(1) per operation
* **Space Complexity:** O(n)

---

## ğŸ§ª Example

```
Input:
push(-2)
push(0)
push(-3)
getMin() â†’ -3
pop()
top() â†’ 0
getMin() â†’ -2
```

---

## ğŸ’» C++ Implementation

```cpp
#include <stack>
using namespace std;
class MinStack {
public:
stack<pair<int,int>> s;
    MinStack() {
        
    }
    
    void push(int val) {
        if(s.empty()){
            s.push({val,val});
        }
        else{
            int minval = min(val,s.top().second);
            s.push({val,minval});
        }
    }
    
    void pop() {
        s.pop();
    }
    
    int top() {
        return s.top().first;
    }    
    int getMin() {
        return s.top().second;
    }
};

## ğŸ“ Folder Structure



## ğŸš€ Key Takeaways

* Auxiliary stack helps track minimum efficiently
* Common interview favorite stack problem
* Builds foundation for advanced stack problems

---

âœ¨ Part of my **Weekly DSA Series** â€” solving LeetCode problems with clean logic and optimal complexity.
